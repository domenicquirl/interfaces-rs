use std::convert::From;
use std::fmt::Write;
use std::fs::{self};
use std::io::{self};
use std::path::{Path, PathBuf};
use std::process::exit;

use std::env;

/// These constants are "dynamically" generated by compiling a C file that includes their value
/// and then including that in the final build.  See `constants.rs` for a function that can be
/// used to retrieve them.
const CONDITIONALLY_AVAILABLE_CONSTANTS: &[&str] = &[
    // IOCTLs
    "SIOCGIFCONF",
    "SIOCGIFHWADDR",
    "SIOCGIFFLAGS",
    "SIOCSIFFLAGS",
    "SIOCGIFMTU",
    "SIOCSIFMTU",
    // Address families
    "AF_LINK",
    "AF_PACKET", // Only on Linux
];

/// These constants are the same as above, but we don't test them for existence with #ifdef.
const ALWAYS_AVAILABLE_CONSTANTS: &[&str] = &["sizeof(struct ifreq)"];

fn main() {
    // Tell `cargo` to rerun build script if we change the template
    println!("cargo:rerun-if-changed=src/constants.c.in");

    let in_path = Path::new("src").join("constants.c.in");
    let out_path = PathBuf::from(env::var_os("OUT_DIR").unwrap()).join("constants.c");

    // Template the file.
    if let Err(e) = generate_constants_file(&in_path, &out_path) {
        println!("Error creating `constants.c`");
        println!("-> {:?}", e);
        exit(1);
    }

    // Build the final library
    let mut cfg = cc::Build::new();

    let helpers_path = Path::new("src").join("helpers.c");

    let cfg = cfg.file(&out_path).file(&helpers_path);

    if env::var_os("CARGO_CFG_TARGET_OS")
        .unwrap()
        .to_str()
        .unwrap()
        == "android"
    {
        let ifaddrs_path = Path::new("src").join("ifaddrs.c");
        cfg.file(ifaddrs_path);
    }

    cfg.compile("interfaces");
}

fn generate_constants_file(in_path: &PathBuf, out_path: &PathBuf) -> Result<(), io::Error> {
    const CONDITIONAL_CONSTANT_MARKER: &str = "        // Conditionally available constants";
    const ALWAYS_AVAILABLE_CONSTANT_MARKER: &str = "        // Always available constants";

    let mut template = fs::read_to_string(in_path)?;

    let insert_conditional_constants_at =
        template.find(CONDITIONAL_CONSTANT_MARKER).unwrap() + CONDITIONAL_CONSTANT_MARKER.len();
    let mut conditional_constants = String::from("\n");
    for &c in CONDITIONALLY_AVAILABLE_CONSTANTS.iter() {
        writeln!(
            &mut conditional_constants,
            "#ifdef {c}\n            {{ \"{c}\", {c} }},\n#endif"
        )
        .unwrap();
    }
    template.insert_str(insert_conditional_constants_at, &conditional_constants);

    let insert_always_available_constants_at =
        template.find(ALWAYS_AVAILABLE_CONSTANT_MARKER).unwrap()
            + ALWAYS_AVAILABLE_CONSTANT_MARKER.len();
    let mut always_available_constants = String::from("\n");
    for &c in ALWAYS_AVAILABLE_CONSTANTS.iter() {
        writeln!(
            &mut always_available_constants,
            "            {{ \"{c}\", {c} }},"
        )
        .unwrap();
    }
    template.insert_str(
        insert_always_available_constants_at,
        &always_available_constants,
    );

    fs::write(out_path, template)?;

    Ok(())
}
